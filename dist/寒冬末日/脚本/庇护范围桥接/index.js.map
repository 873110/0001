{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/寒冬末日/util/shelter_scope.ts","src://tavern_helper_template/src/寒冬末日/界面/outbound.ts","src://tavern_helper_template/src/寒冬末日/脚本/庇护范围桥接/index.ts"],"sourcesContent":["export type ShelterScopeByFloor = Record<string, string[]>;\n\nexport function floorRoomCapacity(level: number, floor: '20' | '19'): number {\n  const lv = Number(level);\n  if (!Number.isFinite(lv)) return 0;\n\n  if (floor === '20') {\n    // 设定：Lv3=3 间，Lv4=6 间，Lv5=12 间（封顶）\n    if (lv < 3) return 0;\n    if (lv === 3) return 3;\n    if (lv === 4) return 6;\n    return 12;\n  }\n\n  // 19 层从等级 6 开始\n  if (lv < 6) return 0;\n  return _.clamp((lv - 5) * 3, 0, 12);\n}\n\nexport function isRoomSheltered(scope: ShelterScopeByFloor, floor: '20' | '19', roomNumber: string): boolean {\n  const list = scope?.[floor] ?? [];\n  if (!Array.isArray(list)) return false;\n  return list.includes(roomNumber);\n}\n\nexport function normalizeScope(scope: ShelterScopeByFloor): ShelterScopeByFloor {\n  const out: ShelterScopeByFloor = {};\n  for (const [floor, rooms] of Object.entries(scope ?? {})) {\n    if (!Array.isArray(rooms)) continue;\n    out[floor] = _(rooms)\n      .filter((x: any) => typeof x === 'string' && x.trim().length > 0)\n      .filter((room: string) => !(floor === '20' && room === '2001'))\n      .uniq()\n      .sortBy()\n      .value();\n  }\n  return out;\n}\n","import type { ShelterScopeByFloor } from '../util/shelter_scope';\n\nexport const CHAT_VAR_KEYS = {\n  EDEN_SHELTER_SCOPE: 'eden.shelter_scope',\n  EDEN_RULES_HEALTH: 'eden.rules.health',\n  EDEN_SHELTER_UPGRADE: 'eden.shelter_upgrade',\n  UI_SETTINGS: 'ui_settings',\n} as const;\n\nexport type SendToChatResult =\n  | { ok: true; method: 'triggerSlash'; sentText: string }\n  | { ok: false; method: 'triggerSlash' | 'unavailable'; reason: string; sentText: string };\n\nexport type CopyTextResult =\n  | { ok: true; method: 'clipboard' | 'execCommand'; text: string }\n  | { ok: false; method: 'clipboard' | 'execCommand'; reason: string; text: string };\n\ntype DebugSetting =\n  | boolean\n  | {\n      enabled?: boolean;\n      toConsole?: boolean;\n      toChat?: boolean;\n    };\n\nconst OUTBOUND_DEBUG_FLAG_PATH = 'ui_settings.debug_outbound';\nconst OUTBOUND_LOG_PATH = 'eden.debug.outbound_log';\nconst OUTBOUND_LOG_MAX = 50;\n\nfunction normalizeChatText(input: string): string {\n  const raw = String(input ?? '');\n  const noNewlines = raw.replace(/\\r?\\n+/g, ' ').trim();\n  // `/send ... | /trigger` 的管道分隔符，避免被用户文本打断\n  return noNewlines.replaceAll('|', '｜');\n}\n\nfunction resolveDebug(debug?: DebugSetting): { enabled: boolean; toConsole: boolean; toChat: boolean } {\n  if (typeof debug === 'boolean') {\n    return { enabled: debug, toConsole: debug, toChat: false };\n  }\n  if (debug && typeof debug === 'object') {\n    const enabled = debug.enabled ?? true;\n    return { enabled, toConsole: debug.toConsole ?? enabled, toChat: debug.toChat ?? false };\n  }\n\n  // 默认：如果 chat 变量里打开了 ui_settings.debug_outbound，就输出到 console（不写回 chat，避免污染存档）\n  try {\n    const vars = getVariables?.({ type: 'chat' }) ?? {};\n    const flag = OUTBOUND_DEBUG_FLAG_PATH.split('.').reduce<any>((acc, k) => (acc ? acc[k] : undefined), vars);\n    const enabled = flag === true;\n    return { enabled, toConsole: enabled, toChat: false };\n  } catch {\n    return { enabled: false, toConsole: false, toChat: false };\n  }\n}\n\nfunction truncateText(text: string, max = 200): string {\n  const s = String(text ?? '');\n  if (s.length <= max) return s;\n  return `${s.slice(0, max)}…`;\n}\n\nfunction setDeep(obj: any, path: string, value: any) {\n  const keys = path.split('.').filter(Boolean);\n  if (keys.length === 0) return;\n  let cur = obj;\n  for (let i = 0; i < keys.length - 1; i++) {\n    const k = keys[i];\n    if (!cur[k] || typeof cur[k] !== 'object') cur[k] = {};\n    cur = cur[k];\n  }\n  cur[keys[keys.length - 1]] = value;\n}\n\nfunction getDeep(obj: any, path: string): any {\n  const keys = path.split('.').filter(Boolean);\n  let cur = obj;\n  for (const k of keys) {\n    if (!cur || typeof cur !== 'object') return undefined;\n    cur = cur[k];\n  }\n  return cur;\n}\n\nfunction debugLog(\n  debug: { enabled: boolean; toConsole: boolean; toChat: boolean },\n  event: string,\n  payload: Record<string, any>,\n) {\n  if (!debug.enabled) return;\n\n  const record = {\n    ts: new Date().toISOString(),\n    event,\n    ...payload,\n  };\n\n  if (debug.toConsole) {\n    // eslint-disable-next-line no-console\n    console.debug?.('[eden/outbound]', record);\n  }\n\n  if (debug.toChat && typeof updateVariablesWith === 'function') {\n    try {\n      updateVariablesWith(\n        (vars: any) => {\n          const current = getDeep(vars, OUTBOUND_LOG_PATH);\n          const list = Array.isArray(current) ? current.slice() : [];\n          list.push(record);\n          if (list.length > OUTBOUND_LOG_MAX) {\n            list.splice(0, list.length - OUTBOUND_LOG_MAX);\n          }\n          setDeep(vars, OUTBOUND_LOG_PATH, list);\n          return vars;\n        },\n        { type: 'chat' },\n      );\n    } catch {\n      // ignore\n    }\n  }\n}\n\nexport function sendToChat(\n  text: string,\n  {\n    toast = true,\n    awaitTrigger = true,\n    debug,\n    successMessage = '已发送到聊天',\n    failureMessage = '发送失败，请复制后手动发送',\n    unavailableMessage = '无法发送：triggerSlash 不可用',\n  }: {\n    toast?: boolean;\n    awaitTrigger?: boolean;\n    debug?: DebugSetting;\n    successMessage?: string;\n    failureMessage?: string;\n    unavailableMessage?: string;\n  } = {},\n): SendToChatResult {\n  const debugResolved = resolveDebug(debug);\n  const sentText = normalizeChatText(text);\n  if (!sentText) {\n    const reason = '空文本';\n    if (toast) toastr?.warning?.(reason);\n    debugLog(debugResolved, 'sendToChat', { ok: false, method: 'unavailable', reason, text: truncateText(text) });\n    return { ok: false, method: 'unavailable', reason, sentText };\n  }\n\n  if (typeof triggerSlash !== 'function') {\n    if (toast) toastr?.error?.(unavailableMessage);\n    debugLog(debugResolved, 'sendToChat', {\n      ok: false,\n      method: 'unavailable',\n      reason: unavailableMessage,\n      text: truncateText(sentText),\n    });\n    return { ok: false, method: 'unavailable', reason: unavailableMessage, sentText };\n  }\n\n  const cmd = awaitTrigger ? `/send ${sentText} | /trigger await=true` : `/send ${sentText}`;\n  try {\n    triggerSlash(cmd);\n    if (toast) toastr?.success?.(successMessage);\n    debugLog(debugResolved, 'sendToChat', { ok: true, method: 'triggerSlash', text: truncateText(sentText) });\n    return { ok: true, method: 'triggerSlash', sentText };\n  } catch (err) {\n    const reason = err instanceof Error ? err.message : String(err);\n    if (toast) toastr?.error?.(failureMessage);\n    debugLog(debugResolved, 'sendToChat', { ok: false, method: 'triggerSlash', reason, text: truncateText(sentText) });\n    return { ok: false, method: 'triggerSlash', reason, sentText };\n  }\n}\n\nexport async function copyText(\n  text: string,\n  {\n    toast = true,\n    debug,\n    successMessage = '已复制',\n    failureMessage = '复制失败，请手动复制',\n  }: { toast?: boolean; debug?: DebugSetting; successMessage?: string; failureMessage?: string } = {},\n): Promise<CopyTextResult> {\n  const debugResolved = resolveDebug(debug);\n  const normalized = String(text ?? '').trim();\n  if (!normalized) {\n    const reason = '空文本';\n    if (toast) toastr?.warning?.(reason);\n    debugLog(debugResolved, 'copyText', { ok: false, method: 'clipboard', reason, text: truncateText(text) });\n    return { ok: false, method: 'clipboard', reason, text: normalized };\n  }\n\n  try {\n    await navigator.clipboard.writeText(normalized);\n    if (toast) toastr?.success?.(successMessage);\n    debugLog(debugResolved, 'copyText', { ok: true, method: 'clipboard', text: truncateText(normalized) });\n    return { ok: true, method: 'clipboard', text: normalized };\n  } catch {\n    // fallback\n  }\n\n  try {\n    const ta = document.createElement('textarea');\n    ta.value = normalized;\n    ta.style.position = 'fixed';\n    ta.style.left = '-9999px';\n    ta.style.top = '0';\n    document.body.appendChild(ta);\n    ta.focus();\n    ta.select();\n    document.execCommand('copy');\n    document.body.removeChild(ta);\n    if (toast) toastr?.success?.(successMessage);\n    debugLog(debugResolved, 'copyText', { ok: true, method: 'execCommand', text: truncateText(normalized) });\n    return { ok: true, method: 'execCommand', text: normalized };\n  } catch (err) {\n    const reason = err instanceof Error ? err.message : String(err);\n    if (toast) toastr?.error?.(failureMessage);\n    debugLog(debugResolved, 'copyText', { ok: false, method: 'execCommand', reason, text: truncateText(normalized) });\n    return { ok: false, method: 'execCommand', reason, text: normalized };\n  }\n}\n\nexport function buildShelterScopeInstructionText(scope: ShelterScopeByFloor): string {\n  const floors = (['20', '19'] as const)\n    .map(floor => ({ floor, rooms: scope?.[floor] ?? [] }))\n    .filter(x => x.rooms.length > 0);\n\n  if (floors.length === 0) return '';\n\n  const parts = floors.map(({ floor, rooms }) => `楼层${floor}的${rooms.join('、')}房间`);\n  return `{{user}}指令伊甸将${parts.join('、以及')}，设为其生存庇护范围，这些房间的通风系统、供暖系统将与伊甸同步：进入该房间的角色将不再因恶劣天气扣减健康值。`;\n}\n","import { floorRoomCapacity, normalizeScope, ShelterScopeByFloor } from '../../util/shelter_scope';\nimport { CHAT_VAR_KEYS } from '../../界面/outbound';\n\ntype ScopeDelta = {\n  add?: ShelterScopeByFloor;\n  remove?: ShelterScopeByFloor;\n  note?: string;\n};\n\nfunction readScopeFromChat(): ShelterScopeByFloor {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const raw = _.get(vars, CHAT_VAR_KEYS.EDEN_SHELTER_SCOPE, {});\n  if (!raw || typeof raw !== 'object') return {};\n  return normalizeScope(raw as any);\n}\n\nfunction writeScopeToChat(scope: ShelterScopeByFloor) {\n  if (typeof updateVariablesWith !== 'function') return;\n  updateVariablesWith(\n    vars => {\n      _.set(vars, CHAT_VAR_KEYS.EDEN_SHELTER_SCOPE, normalizeScope(scope));\n      return vars;\n    },\n    { type: 'chat' },\n  );\n}\n\nfunction clampLevel(level: any): number {\n  const lv = Number(level);\n  return _.clamp(Number.isFinite(lv) ? lv : 1, 1, 10);\n}\n\nfunction toRoomList(input: any): string[] {\n  if (!Array.isArray(input)) return [];\n  return _(input)\n    .filter((x: any) => typeof x === 'string')\n    .map((x: string) => x.trim())\n    .filter(Boolean)\n    .value();\n}\n\nfunction normalizeDelta(raw: any): ScopeDelta | null {\n  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;\n\n  const addRaw = (raw as any).add ?? null;\n  const removeRaw = (raw as any).remove ?? null;\n\n  const add: ShelterScopeByFloor = {};\n  const remove: ShelterScopeByFloor = {};\n\n  // 兼容：如果 AI 直接写了 { \"20\": [...], \"19\": [...] }，视为 add\n  const looksLikeScope =\n    addRaw == null &&\n    removeRaw == null &&\n    (Object.prototype.hasOwnProperty.call(raw, '20') || Object.prototype.hasOwnProperty.call(raw, '19'));\n\n  const srcAdd = looksLikeScope ? raw : addRaw;\n  const srcRemove = looksLikeScope ? null : removeRaw;\n\n  if (srcAdd && typeof srcAdd === 'object' && !Array.isArray(srcAdd)) {\n    for (const floor of ['20', '19']) {\n      const list = toRoomList((srcAdd as any)[floor]);\n      if (list.length) add[floor] = list;\n    }\n  }\n\n  if (srcRemove && typeof srcRemove === 'object' && !Array.isArray(srcRemove)) {\n    for (const floor of ['20', '19']) {\n      const list = toRoomList((srcRemove as any)[floor]);\n      if (list.length) remove[floor] = list;\n    }\n  }\n\n  const note = typeof (raw as any).note === 'string' ? String((raw as any).note) : undefined;\n\n  if (Object.keys(add).length === 0 && Object.keys(remove).length === 0) return null;\n  return {\n    add: Object.keys(add).length ? add : undefined,\n    remove: Object.keys(remove).length ? remove : undefined,\n    note,\n  };\n}\n\nfunction enforceCapacity(list: string[], capacity: number): string[] {\n  if (capacity <= 0) return [];\n  const uniqSorted = _(list)\n    .filter((x: any) => typeof x === 'string' && x.trim().length > 0)\n    .map((x: string) => x.trim())\n    .filter((room: string) => room !== '2001')\n    .uniq()\n    .sortBy()\n    .value();\n  if (uniqSorted.length <= capacity) return uniqSorted;\n  return uniqSorted.slice(0, capacity);\n}\n\nfunction applyDeltaToScope(current: ShelterScopeByFloor, delta: ScopeDelta, level: number): ShelterScopeByFloor {\n  const base = normalizeScope(current);\n  const next: ShelterScopeByFloor = { ...base };\n\n  for (const floor of ['20', '19'] as const) {\n    const cap = floorRoomCapacity(level, floor);\n    const cur = Array.isArray(next[floor]) ? next[floor].slice() : [];\n    const set = new Set<string>(cur);\n\n    for (const room of toRoomList(delta.remove?.[floor])) set.delete(room);\n\n    // 不解锁时忽略 add，但 remove 仍允许清理旧值\n    if (cap > 0) {\n      for (const room of toRoomList(delta.add?.[floor])) {\n        if (room === '2001') continue;\n        if (set.has(room)) continue;\n        if (set.size >= cap) break;\n        set.add(room);\n      }\n    }\n\n    const merged = Array.from(set);\n    const capped = enforceCapacity(merged, cap);\n    if (capped.length > 0) next[floor] = capped;\n    else delete next[floor];\n  }\n\n  return normalizeScope(next);\n}\n\n$(async () => {\n  await waitGlobalInitialized('Mvu');\n\n  const listener = (new_variables: any) => {\n    const stat_data = _.get(new_variables, 'stat_data', {}) ?? {};\n    const rawDelta = _.get(stat_data, ['庇护所', '庇护范围变更'], null);\n    const delta = normalizeDelta(rawDelta);\n    if (!delta) return;\n\n    const level = clampLevel(_.get(stat_data, ['庇护所', '庇护所等级'], 1));\n    const currentScope = readScopeFromChat();\n    const nextScope = applyDeltaToScope(currentScope, delta, level);\n\n    writeScopeToChat(nextScope);\n\n    // 回写镜像：让 AI 能在 stat_data 里读到“最终生效”的庇护范围\n    _.set(stat_data, ['庇护所', '当前生存庇护范围'], nextScope);\n\n    // 清空触发器（保留字段本身），避免下次 VARIABLE_UPDATE_ENDED 重复执行；\n    // 同时保证 AI 后续可继续使用 `replace /stat_data/庇护所/庇护范围变更`（不需要 insert）。\n    _.set(stat_data, ['庇护所', '庇护范围变更'], {});\n  };\n\n  // 放在末尾执行：确保读取到的是“脚本纠偏后”的最终 stat_data（如房间一致性等）\n  eventMakeLast(Mvu.events.VARIABLE_UPDATE_ENDED, listener);\n});\n"],"names":["floorRoomCapacity","level","floor","lv","Number","isFinite","_","clamp","normalizeScope","scope","out","rooms","Object","entries","Array","isArray","filter","x","trim","length","room","uniq","sortBy","value","CHAT_VAR_KEYS","toRoomList","input","map","Boolean","enforceCapacity","list","capacity","uniqSorted","slice","$","async","waitGlobalInitialized","eventMakeLast","Mvu","events","VARIABLE_UPDATE_ENDED","new_variables","stat_data","get","delta","raw","addRaw","add","removeRaw","remove","looksLikeScope","prototype","hasOwnProperty","call","srcAdd","srcRemove","note","String","undefined","keys","normalizeDelta","clampLevel","nextScope","current","next","cap","cur","set","Set","delete","has","size","capped","from","applyDeltaToScope","vars","getVariables","type","readScopeFromChat","updateVariablesWith"],"ignoreList":[],"sourceRoot":""}