{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/寒冬末日/util/time.ts","src://tavern_helper_template/src/寒冬末日/util/room.ts","src://tavern_helper_template/src/寒冬末日/util/health.ts","src://tavern_helper_template/src/寒冬末日/脚本/离场健康结算/index.ts","src://tavern_helper_template/src/寒冬末日/util/shelter_scope.ts"],"sourcesContent":["type ParsedWorldTime = {\n  epochMinutes: number;\n  hour: number;\n  minute: number;\n};\n\nfunction parseDateToEpochDay(dateStr: string): number | null {\n  // 格式：末日纪元，XXXX年XX月XX日\n  const m = (dateStr ?? '').match(/(\\d{1,4})年(\\d{1,2})月(\\d{1,2})日/);\n  if (!m) return null;\n  const year = Number(m[1]);\n  const month = Number(m[2]);\n  const day = Number(m[3]);\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null;\n  const d = new Date(year, month - 1, day);\n  if (Number.isNaN(d.getTime())) return null;\n  return Math.floor(d.getTime() / 86400000);\n}\n\nfunction parseTimeToMinutes(timeStr: string): { hour: number; minute: number } | null {\n  // 格式：时间段 - HH:MM\n  const m = (timeStr ?? '').match(/(\\d{1,2}):(\\d{2})/);\n  if (!m) return null;\n  const hour = Number(m[1]);\n  const minute = Number(m[2]);\n  if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;\n  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;\n  return { hour, minute };\n}\n\nexport function parseWorldTime(dateStr: string, timeStr: string): ParsedWorldTime | null {\n  const day = parseDateToEpochDay(dateStr);\n  const hm = parseTimeToMinutes(timeStr);\n  if (day === null || hm === null) return null;\n  const epochMinutes = day * 1440 + hm.hour * 60 + hm.minute;\n  return { epochMinutes, hour: hm.hour, minute: hm.minute };\n}\n\nexport function diffWorldHours(\n  oldWorld: { 日期?: string; 时间?: string },\n  newWorld: { 日期?: string; 时间?: string },\n): number | null {\n  const oldParsed = parseWorldTime(oldWorld.日期 ?? '', oldWorld.时间 ?? '');\n  const newParsed = parseWorldTime(newWorld.日期 ?? '', newWorld.时间 ?? '');\n  if (!oldParsed || !newParsed) return null;\n  const diffMinutes = newParsed.epochMinutes - oldParsed.epochMinutes;\n  if (!Number.isFinite(diffMinutes)) return null;\n  if (diffMinutes <= 0) return null;\n  return diffMinutes / 60;\n}\n","export type RoomLocation =\n  | { kind: 'entrance'; room: '临时客房A' | '临时客房B' | '玄关' | '净化/隔离区' }\n  | { kind: 'core'; room: '客厅' | '餐厅/厨房' | '主卧室' | '主浴室' }\n  | { kind: 'floor'; floor: string; roomNumber: string }\n  | { kind: 'outdoor'; area: string }\n  | { kind: 'none' };\n\ntype RoomsStatData = any;\n\nexport function normalizeRoomTag(tag: string): string {\n  const raw = String(tag ?? '').trim();\n  if (!raw) return '';\n\n  // 清理误输入的空白（兼容旧存档/手动编辑造成的断行空格）\n  const t = raw.replace(/\\s+/g, '');\n\n  // 兼容旧命名/别名\n  if (t === '核心区/餐厅厨房') return '核心区/餐厅/厨房';\n  if (\n    t === '玄关/隔离区' ||\n    t === '玄关/净化区' ||\n    t === '玄关/净化隔离区' ||\n    t === '玄关/净化/隔离区' ||\n    t === '玄关（净化/隔离区）'\n  )\n    return '玄关/净化/隔离区';\n  if (t.startsWith('室外/')) return `户外/${t.slice('室外/'.length)}`;\n  if (t === '室外') return '户外';\n\n  return t;\n}\n\nexport function parseRoomTag(tag: string): RoomLocation {\n  const t = normalizeRoomTag(tag);\n  if (!t) return { kind: 'none' };\n\n  if (t === '玄关/临时客房A') return { kind: 'entrance', room: '临时客房A' };\n  if (t === '玄关/临时客房B') return { kind: 'entrance', room: '临时客房B' };\n  if (t === '玄关/净化/隔离区') return { kind: 'entrance', room: '净化/隔离区' };\n  if (t === '玄关') return { kind: 'entrance', room: '玄关' };\n\n  if (t === '核心区/主卧室') return { kind: 'core', room: '主卧室' };\n  if (t === '核心区/主浴室') return { kind: 'core', room: '主浴室' };\n  if (t === '核心区/客厅') return { kind: 'core', room: '客厅' };\n  if (t === '核心区/餐厅/厨房') return { kind: 'core', room: '餐厅/厨房' };\n\n  const m = t.match(/^楼层(\\d+)\\/(.+)$/);\n  if (m) {\n    const floor = String(m[1] ?? '').trim();\n    const roomNumber = String(m[2] ?? '').trim();\n    // 严格限制房号为纯数字（避免“2001门外/门口”等不规范字符串进入系统）\n    if (floor && roomNumber && /^\\d{4}$/.test(roomNumber)) return { kind: 'floor', floor, roomNumber };\n  }\n\n  const outdoor = t.match(/^户外\\/(.+)$/);\n  if (outdoor) {\n    const area = String(outdoor[1] ?? '').trim();\n    if (area) return { kind: 'outdoor', area };\n    return { kind: 'outdoor', area: '' };\n  }\n  if (t === '户外') return { kind: 'outdoor', area: '' };\n\n  return { kind: 'none' };\n}\n\nexport function roomTagFromLocation(loc: RoomLocation): string {\n  if (loc.kind === 'entrance') {\n    if (loc.room === '临时客房A') return '玄关/临时客房A';\n    if (loc.room === '临时客房B') return '玄关/临时客房B';\n    if (loc.room === '净化/隔离区') return '玄关/净化/隔离区';\n    return '玄关';\n  }\n  if (loc.kind === 'core') {\n    if (loc.room === '客厅') return '核心区/客厅';\n    if (loc.room === '餐厅/厨房') return '核心区/餐厅/厨房';\n    if (loc.room === '主卧室') return '核心区/主卧室';\n    return '核心区/主浴室';\n  }\n  if (loc.kind === 'floor') return `楼层${loc.floor}/${loc.roomNumber}`;\n  if (loc.kind === 'outdoor') return loc.area ? `户外/${loc.area}` : '户外';\n  return '';\n}\n\nexport function findRoleLocation(rooms: RoomsStatData, roleName: string): RoomLocation {\n  const name = roleName ?? '';\n  if (!name) return { kind: 'none' };\n\n  const entranceA: string[] = _.get(rooms, '玄关.临时客房A入住者', []);\n  if (Array.isArray(entranceA) && entranceA.includes(name)) return { kind: 'entrance', room: '临时客房A' };\n\n  const entranceB: string[] = _.get(rooms, '玄关.临时客房B入住者', []);\n  if (Array.isArray(entranceB) && entranceB.includes(name)) return { kind: 'entrance', room: '临时客房B' };\n\n  const purify: string[] = _.get(rooms, '玄关.净化隔离区入住者', []);\n  if (Array.isArray(purify) && purify.includes(name)) return { kind: 'entrance', room: '净化/隔离区' };\n\n  const bedroom: string[] = _.get(rooms, '核心区.主卧室使用者', []);\n  if (Array.isArray(bedroom) && bedroom.includes(name)) return { kind: 'core', room: '主卧室' };\n\n  const bathroom: string[] = _.get(rooms, '核心区.主浴室使用者', []);\n  if (Array.isArray(bathroom) && bathroom.includes(name)) return { kind: 'core', room: '主浴室' };\n\n  const livingRoom: string[] = _.get(rooms, '核心区.客厅使用者', []);\n  if (Array.isArray(livingRoom) && livingRoom.includes(name)) return { kind: 'core', room: '客厅' };\n\n  const kitchen: string[] = _.get(rooms, '核心区.餐厅厨房使用者', []);\n  if (Array.isArray(kitchen) && kitchen.includes(name)) return { kind: 'core', room: '餐厅/厨房' };\n\n  const floor20: Record<string, any> = _.get(rooms, '楼层房间.楼层20房间', {});\n  if (floor20 && typeof floor20 === 'object') {\n    for (const [roomNumber, data] of Object.entries(floor20)) {\n      const residents: string[] = (data as any)?.入住者 ?? [];\n      if (Array.isArray(residents) && residents.includes(name)) return { kind: 'floor', floor: '20', roomNumber };\n    }\n  }\n\n  const floor19: Record<string, any> = _.get(rooms, '楼层房间.楼层19房间', {});\n  if (floor19 && typeof floor19 === 'object') {\n    for (const [roomNumber, data] of Object.entries(floor19)) {\n      const residents: string[] = (data as any)?.入住者 ?? [];\n      if (Array.isArray(residents) && residents.includes(name)) return { kind: 'floor', floor: '19', roomNumber };\n    }\n  }\n\n  return { kind: 'none' };\n}\n","export type HealthRules = {\n  decayPer6h: number;\n  recoverPer12h: number;\n  decayMultiplier: number;\n  recoverMultiplier: number;\n};\n\nexport function clampHealth(v: number): number {\n  return _.clamp(Number(v) || 0, 0, 100);\n}\n\nexport function healthCondition(health: number): string {\n  const h = clampHealth(health);\n  if (h <= 0) return '死亡';\n  if (h < 30) return '重病/濒死';\n  if (h < 60) return '生病/受伤';\n  if (h < 80) return '亚健康';\n  return '健康';\n}\n\nexport function computeOffstageHealthDelta(\n  deltaHours: number,\n  sheltered: boolean,\n  rules: HealthRules,\n): { delta: number; reason: string } {\n  const dh = Number(deltaHours);\n  if (!Number.isFinite(dh) || dh <= 0) return { delta: 0, reason: '0, 无变化' };\n\n  const decayPer6h = Math.max(0, Number(rules.decayPer6h) || 0);\n  const recoverPer12h = Math.max(0, Number(rules.recoverPer12h) || 0);\n  const decayMultiplier = Math.max(0, Number(rules.decayMultiplier) || 0);\n  const recoverMultiplier = Math.max(0, Number(rules.recoverMultiplier) || 0);\n\n  if (sheltered) {\n    const steps = Math.floor(dh / 12);\n    const delta = Math.floor(steps * recoverPer12h * recoverMultiplier);\n    if (!delta) return { delta: 0, reason: '0, 无变化' };\n    return { delta, reason: `+${delta}, 离场受庇护休整` };\n  }\n\n  const steps = Math.floor(dh / 6);\n  const delta = -Math.floor(steps * decayPer6h * decayMultiplier);\n  if (!delta) return { delta: 0, reason: '0, 无变化' };\n  return { delta, reason: `${delta}, 离场未受庇护自然衰减` };\n}\n","import { diffWorldHours } from '../../util/time';\nimport { parseRoomTag } from '../../util/room';\nimport { normalizeScope, ShelterScopeByFloor, isRoomSheltered } from '../../util/shelter_scope';\nimport { clampHealth, computeOffstageHealthDelta, healthCondition, HealthRules } from '../../util/health';\n\ntype RoleLike = {\n  姓名?: string;\n  健康?: number;\n  健康更新原因?: string;\n  健康状况?: string;\n  内心想法?: string;\n  登场状态?: string;\n  关系?: string;\n  关系倾向?: string;\n  秩序刻印?: number;\n  秩序刻印更新原因?: string;\n};\n\ntype RoleTouched = {\n  health: boolean;\n  healthReason: boolean;\n  relation: boolean;\n  relationTendency: boolean;\n  imprint: boolean;\n  imprintReason: boolean;\n  thought: boolean;\n};\n\nfunction parseTimeStrToMinutes(timeStr: string): number | null {\n  const m = (timeStr ?? '').match(/(\\d{1,2}):(\\d{2})/);\n  if (!m) return null;\n  const hour = Number(m[1]);\n  const minute = Number(m[2]);\n  if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;\n  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;\n  return hour * 60 + minute;\n}\n\nfunction parseDateStr(dateStr: string): { year: number; month: number; day: number } | null {\n  const m = (dateStr ?? '').match(/(\\d{1,4})年(\\d{1,2})月(\\d{1,2})日/);\n  if (!m) return null;\n  const year = Number(m[1]);\n  const month = Number(m[2]);\n  const day = Number(m[3]);\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null;\n  return { year, month, day };\n}\n\nfunction formatDateStr(date: Date): string {\n  return `末日纪元，${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;\n}\n\nfunction readDebugFlagsFromChat(): { dateLogic: boolean; offstageHealth: boolean } {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const debug = _.get(vars, 'eden.debug', {}) ?? {};\n  return {\n    dateLogic: _.get(debug, 'date_logic', false) === true,\n    offstageHealth: _.get(debug, 'offstage_health', false) === true,\n  };\n}\n\nfunction relationStageFromImprint(mark: number): '无' | '拒绝' | '交易' | '顺从' | '忠诚' | '性奴' {\n  const v = _.clamp(Number(mark) || 0, 0, 100);\n  if (v <= 0) return '无';\n  if (v < 20) return '拒绝';\n  if (v < 40) return '交易';\n  if (v < 60) return '顺从';\n  if (v < 90) return '忠诚';\n  return '性奴';\n}\n\nfunction readShelterScopeFromChat(): ShelterScopeByFloor {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const raw = _.get(vars, 'eden.shelter_scope', {});\n  if (!raw || typeof raw !== 'object') return {};\n  return normalizeScope(raw as any);\n}\n\nfunction readHealthRulesFromChat(): HealthRules {\n  const vars = getVariables({ type: 'chat' }) ?? {};\n  const raw = _.get(vars, 'eden.rules.health', {}) ?? {};\n  const r = raw as Partial<HealthRules>;\n  return {\n    decayPer6h: _.clamp(Number(r.decayPer6h) || 5, 0, 10),\n    recoverPer12h: _.clamp(Number(r.recoverPer12h) || 1, 0, 10),\n    decayMultiplier: _.clamp(Number(r.decayMultiplier) || 1, 0, 10),\n    recoverMultiplier: _.clamp(Number(r.recoverMultiplier) || 1, 0, 10),\n  };\n}\n\nfunction isShelteredForRole(stat_data: any, rolePath: string, scope: ShelterScopeByFloor): boolean {\n  const tag = _.get(stat_data, `${rolePath}.所在房间`, '');\n  const loc = parseRoomTag(tag);\n  if (loc.kind === 'core' || loc.kind === 'entrance') return true;\n  if (loc.kind === 'floor') {\n    if (loc.floor === '20' && loc.roomNumber === '2001') return true;\n    // 仅对当前支持的楼层（19/20）做庇护范围判定；其它楼层（如 30/40）暂视为未受庇护\n    if (loc.floor === '20' || loc.floor === '19') return isRoomSheltered(scope, loc.floor, loc.roomNumber);\n    return false;\n  }\n  return false;\n}\n\nfunction isRoleLike(val: any): val is RoleLike {\n  return val && typeof val === 'object' && '健康' in val && '登场状态' in val;\n}\n\nfunction mergeRoleLike(coreRole: RoleLike, tempRole: RoleLike): RoleLike {\n  const next: any = _.cloneDeep(coreRole);\n  for (const [key, value] of Object.entries(tempRole ?? {})) {\n    const cur = next[key];\n    if (cur === undefined || cur === null) {\n      next[key] = value;\n      continue;\n    }\n    if (typeof cur === 'string' && cur.trim() === '' && typeof value === 'string' && value.trim() !== '') {\n      next[key] = value;\n      continue;\n    }\n    if (Array.isArray(cur) && cur.length === 0 && Array.isArray(value) && value.length > 0) {\n      next[key] = value.slice();\n      continue;\n    }\n  }\n  return next as RoleLike;\n}\n\nfunction mergeTempNpcIntoCore(stat_data: any) {\n  const temp = _.get(stat_data, '临时NPC', {});\n  if (!temp || typeof temp !== 'object' || Array.isArray(temp)) return;\n\n  for (const [name, tempRole] of Object.entries(temp)) {\n    if (typeof name !== 'string' || !name) continue;\n    if (!isRoleLike(tempRole)) continue;\n    const coreRole = _.get(stat_data, name, null);\n    if (!isRoleLike(coreRole)) continue;\n\n    const next = mergeRoleLike(coreRole, tempRole as RoleLike);\n    _.set(stat_data, name, next);\n    _.unset(stat_data, ['临时NPC', name]);\n  }\n}\n\nfunction diffRoleTouched(oldRole: RoleLike | null, newRole: RoleLike): RoleTouched {\n  if (!oldRole) {\n    return {\n      health: false,\n      healthReason: false,\n      relation: false,\n      relationTendency: false,\n      imprint: false,\n      imprintReason: false,\n      thought: false,\n    };\n  }\n  return {\n    health: !_.isEqual(oldRole.健康, newRole.健康),\n    healthReason: !_.isEqual(oldRole.健康更新原因, newRole.健康更新原因),\n    relation: !_.isEqual(oldRole.关系, newRole.关系),\n    relationTendency: !_.isEqual(oldRole.关系倾向, newRole.关系倾向),\n    imprint: !_.isEqual(oldRole.秩序刻印, newRole.秩序刻印),\n    imprintReason: !_.isEqual(oldRole.秩序刻印更新原因, newRole.秩序刻印更新原因),\n    thought: !_.isEqual(oldRole.内心想法, newRole.内心想法),\n  };\n}\n\nfunction applyAutoStageFromThoughtUpdateIfNeeded(\n  rolePath: string,\n  roleName: string,\n  oldRole: RoleLike | null,\n  newRole: RoleLike,\n  debug?: { offstageHealth: boolean },\n) {\n  if (!oldRole) return;\n  if (oldRole.登场状态 !== '离场') return;\n  if (newRole.登场状态 !== '离场') return;\n\n  const touched = diffRoleTouched(oldRole, newRole);\n  if (!touched.thought) return;\n\n  const nextThought = String(newRole.内心想法 ?? '').trim();\n  if (!nextThought) return;\n\n  // AI 本轮更新了内心想法，通常代表“在场/正在互动”，但可能遗漏把登场状态改为登场\n  _.set(newRole, '登场状态', '登场');\n  if (debug?.offstageHealth) {\n    console.log(`[OffstageHealth] auto-stage from thought update: ${rolePath} (${roleName})`);\n  }\n}\n\nfunction applyOffstageRoleHealthIfNeeded(\n  rolePath: string,\n  roleName: string,\n  oldRole: RoleLike | null,\n  newRole: RoleLike,\n  stat_data: any,\n  deltaHours: number | null,\n  scope: ShelterScopeByFloor,\n  rules: HealthRules,\n  debug?: { offstageHealth: boolean },\n) {\n  if (newRole.登场状态 !== '离场') return;\n  if (!oldRole) return;\n  if (deltaHours === null) return;\n\n  // 规则：只要 AI 本轮对“健康/健康更新原因”有指令，就认为是剧情介入，脚本不做基础结算\n  const touched = diffRoleTouched(oldRole, newRole);\n  if (touched.health || touched.healthReason) {\n    if (debug?.offstageHealth) {\n      console.log(\n        `[OffstageHealth] skip(${roleName}): touched by AI (health=${touched.health}, reason=${touched.healthReason})`,\n      );\n    }\n    return;\n  }\n\n  const currentHealth = clampHealth(Number(newRole.健康) || 0);\n  const sheltered = isShelteredForRole(stat_data, rolePath, scope);\n  const computed = computeOffstageHealthDelta(deltaHours, sheltered, rules);\n  if (!computed.delta) {\n    if (debug?.offstageHealth) {\n      console.log(`[OffstageHealth] no-op(${roleName}): dh=${deltaHours.toFixed(2)}, sheltered=${sheltered}`);\n    }\n    return;\n  }\n\n  const nextHealth = clampHealth(currentHealth + computed.delta);\n  const actualDelta = nextHealth - currentHealth;\n\n  const label =\n    computed.reason.split(',').slice(1).join(',').trim() || (sheltered ? '离场受庇护休整' : '离场未受庇护自然衰减');\n  const reasonText = actualDelta ? `${actualDelta > 0 ? `+${actualDelta}` : `${actualDelta}`}, ${label}` : '0, 无变化';\n\n  _.set(stat_data, `${rolePath}.健康`, nextHealth);\n  _.set(stat_data, `${rolePath}.健康更新原因`, reasonText);\n  console.log(`[离场健康结算] ${roleName}: ${currentHealth} → ${nextHealth} (${reasonText})`);\n}\n\nfunction applyDeathFromNegativeImprintIfNeeded(\n  rolePath: string,\n  roleName: string,\n  role: RoleLike,\n  stat_data: any,\n  debug?: { offstageHealth: boolean },\n): boolean {\n  const markRaw = role.秩序刻印;\n  if (typeof markRaw !== 'number' && typeof markRaw !== 'string') return false;\n\n  const mark = Number(markRaw);\n  if (!Number.isFinite(mark) || mark >= 0) return false;\n\n  const currentHealth = clampHealth(Number(role.健康) || 0);\n  if (currentHealth <= 0) return false;\n\n  const reasonText = `${-currentHealth}, 羞愧而死`;\n\n  _.set(stat_data, `${rolePath}.健康`, 0);\n  _.set(stat_data, `${rolePath}.健康更新原因`, reasonText);\n  _.set(stat_data, `${rolePath}.登场状态`, '离场');\n\n  console.log(`[角色死亡] ${roleName}: Imp=${mark} -> 健康 ${currentHealth} → 0 (${reasonText})`);\n  if (debug?.offstageHealth) {\n    console.log(`[OffstageHealth] applied death rule: ${rolePath} (${roleName})`);\n  }\n  return true;\n}\n\nfunction applyDerivedHealthStatus(rolePath: string, role: RoleLike, stat_data: any) {\n  const health = clampHealth(Number(role.健康) || 0);\n  const expected = healthCondition(health);\n  if (role.健康状况 !== expected) {\n    _.set(stat_data, `${rolePath}.健康状况`, expected);\n  }\n}\n\nfunction applyDerivedRelationStage(rolePath: string, oldRole: RoleLike | null, newRole: RoleLike, stat_data: any) {\n  const markRaw = newRole.秩序刻印;\n  if (typeof markRaw !== 'number' && typeof markRaw !== 'string') return;\n  const stage = relationStageFromImprint(Number(markRaw));\n\n  // 规则：脚本只在阈值导致阶段变化时写回关系；若 AI 本轮明确更新了关系，则不覆盖\n  const touched = diffRoleTouched(oldRole, newRole);\n  if (touched.relation) return;\n\n  if (newRole.关系 !== stage) {\n    _.set(stat_data, `${rolePath}.关系`, stage);\n  }\n}\n\n$(async () => {\n  await waitGlobalInitialized('Mvu');\n\n  eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, (new_variables, old_variables) => {\n    const debug = readDebugFlagsFromChat();\n    const oldWorld = _.get(old_variables, 'stat_data.世界', {});\n\n    // 跨午夜自动补日期：避免 AI 把时间从 23:xx 推进到 01:xx 但忘记 日期/末日天数 +1，导致 diffWorldHours 判定“时间未前进”\n    // 注意：若同时部署了 `src/寒冬末日/脚本/日期逻辑/index.ts`，请二选一，避免重复 +1\n    {\n      const oldTimeStr = _.get(old_variables, 'stat_data.世界.时间', '');\n      const newTimeStr = _.get(new_variables, 'stat_data.世界.时间', '');\n      if (oldTimeStr !== newTimeStr) {\n        const oldMinutes = parseTimeStrToMinutes(oldTimeStr);\n        const newMinutes = parseTimeStrToMinutes(newTimeStr);\n        if (oldMinutes !== null && newMinutes !== null && oldMinutes > newMinutes) {\n          console.log(`[DateLogic] Detected midnight crossing: ${oldTimeStr} -> ${newTimeStr}`);\n          const oldDateStr = _.get(old_variables, 'stat_data.世界.日期', '');\n          const newDateStr = _.get(new_variables, 'stat_data.世界.日期', '');\n          if (oldDateStr === newDateStr) {\n            console.log('[DateLogic] AI did not update date, patching date/day...');\n            const parsed = parseDateStr(oldDateStr);\n            if (parsed) {\n              const dateObj = new Date(parsed.year, parsed.month - 1, parsed.day);\n              if (!Number.isNaN(dateObj.getTime())) {\n                dateObj.setDate(dateObj.getDate() + 1);\n                const patched = formatDateStr(dateObj);\n                _.set(new_variables, 'stat_data.世界.日期', patched);\n\n                const oldDays = _.get(new_variables, 'stat_data.世界.末日天数');\n                if (typeof oldDays === 'number') {\n                  _.set(new_variables, 'stat_data.世界.末日天数', oldDays + 1);\n                }\n                const daysAfter = _.get(new_variables, 'stat_data.世界.末日天数');\n                console.log(`[DateLogic] patched date: ${oldDateStr} -> ${patched}; days: ${oldDays} -> ${daysAfter}`);\n              } else if (debug.dateLogic) {\n                console.log(`[DateLogic] cannot parse date to Date(): ${oldDateStr}`);\n              }\n            } else if (debug.dateLogic) {\n              console.log(`[DateLogic] cannot parse date string: ${oldDateStr}`);\n            }\n          } else if (debug.dateLogic) {\n            console.log(`[DateLogic] date already updated by AI: ${oldDateStr} -> ${newDateStr}`);\n          }\n        } else if (debug.dateLogic) {\n          console.log(\n            `[DateLogic] time changed but not crossing: ${oldTimeStr} -> ${newTimeStr} (oldMin=${oldMinutes}, newMin=${newMinutes})`,\n          );\n        }\n      } else if (debug.dateLogic) {\n        console.log('[DateLogic] time unchanged; no date check.');\n      }\n    }\n\n    const newWorld = _.get(new_variables, 'stat_data.世界', {});\n    const deltaHours = diffWorldHours(oldWorld, newWorld);\n    if (deltaHours === null) {\n      const oldTimeStr = _.get(old_variables, 'stat_data.世界.时间', '');\n      const newTimeStr = _.get(new_variables, 'stat_data.世界.时间', '');\n      if (oldTimeStr !== newTimeStr) {\n        console.log('[DateLogic] diffWorldHours=null', { oldWorld, newWorld });\n      } else if (debug.dateLogic) {\n        console.log('[DateLogic] diffWorldHours=null (time unchanged)', { oldWorld, newWorld });\n      }\n    } else if (debug.dateLogic) {\n      console.log(`[DateLogic] diffWorldHours=${deltaHours.toFixed(2)}`);\n    }\n\n    const stat_data = _.get(new_variables, 'stat_data', {});\n    const old_stat_data = _.get(old_variables, 'stat_data', {});\n\n    // 若同名角色同时存在于顶层与临时NPC，自动合并并移除临时NPC\n    mergeTempNpcIntoCore(stat_data);\n\n    const scope = readShelterScopeFromChat();\n    const rules = readHealthRulesFromChat();\n\n    const reserved = new Set(['世界', '庇护所', '房间', '主线任务', '楼层其他住户', '临时NPC']);\n    for (const [key, val] of Object.entries(stat_data ?? {})) {\n      if (reserved.has(key)) continue;\n      if (typeof key !== 'string' || key.startsWith('_')) continue;\n      if (!isRoleLike(val)) continue;\n\n      const oldRole = _.get(old_stat_data, key, null) as any as RoleLike | null;\n      applyAutoStageFromThoughtUpdateIfNeeded(key, key, oldRole, val as any, debug);\n      applyDeathFromNegativeImprintIfNeeded(key, key, val as any, stat_data, debug);\n      applyOffstageRoleHealthIfNeeded(key, key, oldRole, val as any, stat_data, deltaHours, scope, rules, debug);\n      applyDerivedHealthStatus(key, val as any, stat_data);\n      applyDerivedRelationStage(key, oldRole, val as any, stat_data);\n    }\n\n    const tempNpc = _.get(stat_data, '临时NPC', {});\n    if (tempNpc && typeof tempNpc === 'object') {\n      for (const [name, val] of Object.entries(tempNpc)) {\n        if (typeof name !== 'string' || !name) continue;\n        if (!isRoleLike(val)) continue;\n\n        const oldRole = _.get(old_stat_data, `临时NPC.${name}`, null) as any as RoleLike | null;\n        applyAutoStageFromThoughtUpdateIfNeeded(`临时NPC.${name}`, name, oldRole, val as any, debug);\n        applyDeathFromNegativeImprintIfNeeded(`临时NPC.${name}`, name, val as any, stat_data, debug);\n        applyOffstageRoleHealthIfNeeded(\n          `临时NPC.${name}`,\n          name,\n          oldRole,\n          val as any,\n          stat_data,\n          deltaHours,\n          scope,\n          rules,\n          debug,\n        );\n        applyDerivedHealthStatus(`临时NPC.${name}`, val as any, stat_data);\n        applyDerivedRelationStage(`临时NPC.${name}`, oldRole, val as any, stat_data);\n      }\n    }\n  });\n});\n","export type ShelterScopeByFloor = Record<string, string[]>;\n\nexport function floorRoomCapacity(level: number, floor: '20' | '19'): number {\n  const lv = Number(level);\n  if (!Number.isFinite(lv)) return 0;\n\n  if (floor === '20') {\n    // 设定：Lv3=3 间，Lv4=6 间，Lv5=12 间（封顶）\n    if (lv < 3) return 0;\n    if (lv === 3) return 3;\n    if (lv === 4) return 6;\n    return 12;\n  }\n\n  // 19 层从等级 6 开始\n  if (lv < 6) return 0;\n  return _.clamp((lv - 5) * 3, 0, 12);\n}\n\nexport function isRoomSheltered(scope: ShelterScopeByFloor, floor: '20' | '19', roomNumber: string): boolean {\n  const list = scope?.[floor] ?? [];\n  if (!Array.isArray(list)) return false;\n  return list.includes(roomNumber);\n}\n\nexport function normalizeScope(scope: ShelterScopeByFloor): ShelterScopeByFloor {\n  const out: ShelterScopeByFloor = {};\n  for (const [floor, rooms] of Object.entries(scope ?? {})) {\n    if (!Array.isArray(rooms)) continue;\n    out[floor] = _(rooms)\n      .filter((x: any) => typeof x === 'string' && x.trim().length > 0)\n      .filter((room: string) => !(floor === '20' && room === '2001'))\n      .uniq()\n      .sortBy()\n      .value();\n  }\n  return out;\n}\n"],"names":["parseWorldTime","dateStr","timeStr","day","m","match","year","Number","month","isFinite","d","Date","isNaN","getTime","Math","floor","parseDateToEpochDay","hm","hour","minute","parseTimeToMinutes","epochMinutes","parseRoomTag","tag","t","raw","String","trim","replace","startsWith","slice","normalizeRoomTag","kind","room","roomNumber","test","outdoor","area","clampHealth","v","_","clamp","parseTimeStrToMinutes","readShelterScopeFromChat","vars","getVariables","type","get","scope","out","rooms","Object","entries","Array","isArray","filter","x","length","uniq","sortBy","value","normalizeScope","isShelteredForRole","stat_data","rolePath","loc","list","includes","isRoomSheltered","isRoleLike","val","mergeRoleLike","coreRole","tempRole","next","cloneDeep","key","cur","diffRoleTouched","oldRole","newRole","health","isEqual","healthReason","relation","relationTendency","imprint","imprintReason","thought","applyAutoStageFromThoughtUpdateIfNeeded","roleName","debug","set","offstageHealth","console","log","applyOffstageRoleHealthIfNeeded","deltaHours","rules","touched","currentHealth","sheltered","computed","dh","delta","reason","decayPer6h","max","recoverPer12h","decayMultiplier","recoverMultiplier","steps","computeOffstageHealthDelta","toFixed","nextHealth","actualDelta","label","split","join","reasonText","applyDeathFromNegativeImprintIfNeeded","role","markRaw","mark","applyDerivedHealthStatus","expected","h","healthCondition","applyDerivedRelationStage","stage","relationStageFromImprint","$","async","waitGlobalInitialized","eventOn","Mvu","events","VARIABLE_UPDATE_ENDED","new_variables","old_variables","dateLogic","readDebugFlagsFromChat","oldWorld","oldTimeStr","newTimeStr","oldMinutes","newMinutes","oldDateStr","newDateStr","parsed","parseDateStr","dateObj","setDate","getDate","patched","date","getFullYear","getMonth","oldDays","daysAfter","newWorld","oldParsed","newParsed","diffMinutes","diffWorldHours","old_stat_data","temp","name","unset","mergeTempNpcIntoCore","r","readHealthRulesFromChat","reserved","Set","has","tempNpc"],"ignoreList":[],"sourceRoot":""}